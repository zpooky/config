export http_proxy="http://wwwproxy.se.axis.com:3128"
export HTTP_PROXY="${http_proxy}"

export ftp_proxy="http://wwwproxy.se.axis.com:3128"
export FTP_PROXY="${ftp_proxy}"

export https_proxy="http://wwwproxy.se.axis.com:3128"
export HTTPS_PROXY="${https_proxy}"

export no_proxy=192.168.0.90,localhost,127.0.0.1,127.0.1.1,.localdomain,axis.com

# export ftp_proxy="ftp://ftp-proxy.se.axis.com:4514/"
# export FTP_PROXY="ftp://ftp-proxy.se.axis.com:4514/"
# export socks_proxy="socks://socks.axis.com:1080/"
# export SOCKS_PROXY="socks://socks.axis.com:1080/"

# source to give access to build tools functions
source ~/development/axis/oe-setup/oe-setup.sh

function axis_enable_root_192_168_0_90(){
  local l_ip="192.168.0.90"
  local resp=$(curl --noproxy "*" --connect-timeout 5 'http://192.168.0.90/axis-cgi/pwdgrp.cgi?action=add&user=root&pwd=pass&grp=root&sgrp=admin:operator:viewer:ptz' -w "%{http_code}" 2>/dev/null)
  echo "${resp}"

  local code=$(echo "${resp}" | tail -1)

  if [ "${code}" = "200" ]; then
    return 0
  elif [ "${code}" = "401" ]; then
    return 1
  fi

  return 2
}

function setup_ssh_eager() {
  local res=1
  local cnt=0
  local l_ip="192.168.0.90"
  local disable_setup="/tmp/disable_setup"

  local tout=2
  local max_time=240

  # nc -w is timeout in seconds
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    echo "nc -vz -w ${tout} ${l_ip} 80 2> /dev/null"
    nc -vz -w ${tout} ${l_ip} 80 2> /dev/null
    res=$?
    sleep 1
    cnt=$((cnt+tout+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP HTTP probe" "after $cnt seconds"
    return 1
  fi

  local res=2
  while [ $res -eq 2 ] && [ $cnt -lt $max_time ]; do
    axis_enable_root_192_168_0_90
    res=$?
    sleep ${tout}s
    cnt=$((cnt+tout))
  done

  if [ ! $res -eq 2 ]; then
    touch "${disable_setup}"
  else
    notify-send "GAVE UP setup root account" "after $cnt seconds"
    return 1
  fi

  sleep 5
  cnt=$((cnt+5))

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    $HOME/development/axis/tpp/ff enable-ssh 2>&1
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "nc -vz -w ${tout} ${l_ip} 22 2> /dev/null"
      nc -vz -w ${tout} ${l_ip} 22 2> /dev/null
      res=$?
    fi

    if [ ! $res -eq 0 ]; then
      sleep $tout
      cnt=$((cnt+tout))
    fi
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE enable-ssh" "after $cnt seconds"
    return 1
  fi

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    echo "nc -vz -w ${tout} ${l_ip} 22 2> /dev/null"
    nc -vz -w ${tout} ${l_ip} 22 2> /dev/null
    res=$?
    sleep 1
    cnt=$((cnt+tout+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP nc port 22" "after $cnt seconds"
    return 1
  fi

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    ssh_192_168_0_90_execute "ls"
    res=$?
    sleep 1
    cnt=$((cnt+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP ssh ls" "after $cnt seconds"
    return 1
  fi

  return ${res}
}


function ssh_192_168_0_90() {
  function sshx() {
    local l_user="root"
    local l_pass="pass"
    local l_ip="192.168.0.90"

    local l_env_setup='ENV=$HOME/.shinit; export ENV;'
    local l_env=''
    l_env+='echo "alias vim=vi" > $HOME/.shinit'
    l_env+=' && echo "alias ll=\"ls -alh\"" >> $HOME/.shinit'
    l_env+=' && echo "alias systemctl_status=\"systemctl status audiocontrol monolith parhand ioboxd\"" >> $HOME/.shinit'
    l_env+=' && echo "alias systemctl_root=\"cd /usr/lib/systemd/system\"" >> $HOME/.shinit'
    l_env+=' && echo "alias tree=\"ls -alhR1\"" >> $HOME/.shinit'
    l_env+=' && echo "alias port_scan=\"netstat -lnptux\"" >> $HOME/.shinit'
    l_env+=' && echo "alias sp-sd=\"cd /var/spool/storage/SD_DISK\"" >> $HOME/.shinit'
    # AF_UNIX socket
    l_env+=' && echo "alias unix_con=\"netstat -apnx\"" >> $HOME/.shinit'

    local disable_setup="/tmp/disable_setup"
    if [ -e "${disable_setup}" ]; then
      # disable some web menus
      ssh_192_168_0_90_execute "parhandclient set root.System.CaptureFrequencySet yes"
      local res=$?

      if [ $res -eq 0 ]; then
        ssh_192_168_0_90_execute "parhandclient set root.System.CaptureModeSet yes"
        local res=$?
      fi

      if [ $res -eq 0 ]; then
        rm "${disable_setup}"
      fi
    fi

  # sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} 'alias ll="ls -alh";ll; exec /bin/sh -l' # 'alias ll="ls-alh"; /bin/sh -l'
    TERM=xterm sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "${l_env_setup} ${l_env}; exec /bin/sh -l"
    return $?
  }

  sshx
  local res=$?
  echo "res: $res"
  if [ $res -eq 127 ]; then
    echo ""
  # elif [ $res -eq 255 ]; then
  #   echo ""
  elif [ ! $res -eq 0 ]; then

    setup_ssh_eager
    if [ $? -eq 0 ]; then
      sshx
    fi
  fi

  # hides functions from global scope
  unset -f sshx
}


function scp_192_168_0_90() {
  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"

  local l_source="$1"
  local l_remote_dest="$2"
  if [ ! -e "${l_source}" ]; then
    echo "not existing src: '${l_source}'"
    return 1
  fi

  axis_enable_root_192_168_0_90

  sshpass -p "${l_pass}" scp "${l_source}" "${l_user}"@"${l_ip}":"${l_remote_dest}"
}

function scp_crashdump_192_168_0_90(){
  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"

  local l_source='/var/spool/storage/SD_DISK/dumps/*'
  local l_dest="~/development/crashdump/"

  axis_enable_root_192_168_0_90

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_source} ${l_dest}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_source}" "${l_dest}"
}

# function crashdump_gdb_(){
#   if [ ! -n "${BUILDDIR}" ]; then
#     echo "Must be run from oe-initenv shell">&2
#     return 1
#   fi
#
#   function get_build(){
#     # BUILDDIR=/home/fredriol/dists/m3047-iobox-duo-sound/builds/m3047-p
#   }
# # $BUILDDIR
# }

function valid_build_dir() {
  if [ ! -n "${BUILDDIR}" ]; then
    echo "Must be run from oe-initenv shell">&2
    return 1
  fi

  if [[ ! "$(pwd)" =~ ^${BUILDDIR}.* ]]; then
    echo "ERROR: You are not located under the directory of oe-initenv ('${BUILDDIR}')"
    return 1
  fi

  return 0
}

function overlay_mount_192_168_0_90_async(){
  local l_fwmgr_local="/tmp/fwmgr.conf"
  local l_fwmgr_remote="/etc/fwmgr.conf"

  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"
  local res=0

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
  if [ ! $? -eq 0 ]; then
    echo "- mounting overlay fs"
    echo "overlay_usr=all" > "${l_fwmgr_local}"

    echo "sshpass -p ${l_pass} scp ${l_fwmgr_local} ${l_user}@${l_ip}:${l_fwmgr_remote}"
    sshpass -p "${l_pass}" scp "${l_fwmgr_local}" "${l_user}"@"${l_ip}":"${l_fwmgr_remote}"
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "failed mounting"
      exit $res
    fi

    reboot_192_168_0_90_async
  else
    echo "- already mounted overlay fs"
  fi

  return ${res}
}

function overlay_mount_192_168_0_90(){
  # TODO duplicate
  local l_fwmgr_local="/tmp/fwmgr.conf"
  local l_fwmgr_remote="/etc/fwmgr.conf"

  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"
  local res=0

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
  if [ ! $? -eq 0 ]; then
    echo "- mounting overlay fs"
    echo "overlay_usr=all" > "${l_fwmgr_local}"

    echo "sshpass -p ${l_pass} scp ${l_fwmgr_local} ${l_user}@${l_ip}:${l_fwmgr_remote}"
    sshpass -p "${l_pass}" scp "${l_fwmgr_local}" "${l_user}"@"${l_ip}":"${l_fwmgr_remote}"
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "failed mounting"
      exit $res
    fi

    reboot_192_168_0_90
  else
    echo "- already mounted overlay fs"
  fi

  return ${res}
}

# TODO sshfs mount camera in some work dir that will be used by makefile
# TODO find command to setup env(to override dest) and run make with corretch binaries
function deploy_192_168_0_90(){
  local project="${1}"
  local project_dir="${BUILDDIR}/workspace/sources/${project}"

  local l_reboot=false
  local l_systemd=false
  # local l_systemd_restart=false

  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"

  if ! valid_build_dir; then
    return 1
  fi

  if [ ! -e "${project_dir}" ]; then
    echo "'${project_dir}' does not exist" >&2
    return 2
  fi

  axis_enable_root_192_168_0_90
  $HOME/development/axis/tpp/ff enable-ssh

  if [ "${project}" = "ioboxd" ]; then
    local l_dest="/usr/bin/ioboxd"
    local l_source="${project_dir}/oe-workdir/package/usr/bin/ioboxd"
    local l_systemd_name="ioboxd"
    l_systemd=true
  elif [ "${project}" = "monolith" ]; then
    local l_dest="/usr/bin/monolith"
    local l_source="${project_dir}/monolith/oe-workdir/package/usr/bin/monolith"
    local l_systemd_name="monolith"
    l_systemd=true
  elif [ "${project}" = "wsd" ]; then
    local l_dest="/usr/bin/wsd"
    local l_source="${project_dir}/oe-workdir/package/usr/bin/wsd"
    local l_systemd_name="wsd"
    l_systemd=true
  elif [ "${project}" = "audiocontrol" ]; then
    local l_dest="/usr/bin/audiocontrol"
    local l_source="${project_dir}/oe-workdir/package/usr/bin/audiocontrol"
    local l_systemd_name="audiocontrol"
    l_systemd=true
  elif [ "${project}" = "audio-streaming-caps-cgi" ]; then
    local l_dest="/usr/html/axis-cgi/audio/streamingcapabilities.cgi"
    local l_source="${project_dir}/oe-workdir/package/usr/html/axis-cgi/audio/streamingcapabilities.cgi"
    local l_systemd_name="httpd"
    l_systemd=true
  elif [ "${project}" = "audio-service" ]; then
    local l_dest="/usr/bin/audio-service"
    local l_source="${project_dir}/audio-service/oe-workdir/package/usr/bin/audio-service"
    local l_systemd_name="audio-service"
    l_systemd=true
  elif [ "${project}" = "audiodevicecontrol-cgi" ]; then
    local l_dest="/usr/html/axis-cgi/audiodevicecontrol.cgi"
    local l_source="${project_dir}/oe-workdir/package/usr/html/axis-cgi/audiodevicecontrol.cgi"
    local l_systemd_name="httpd"
    l_systemd=true
  elif [ "${project}" = "mediaclip-cgi" ]; then
    local l_source="${project_dir}/oe-workdir/package/usr/html/axis-cgi"

    local src_mediaclip="${l_source}/mediaclip.cgi"
    local src_playclip="${l_source}/playclip.cgi"

    local l_systemd_name="httpd"

    # devtool_build "${project}"
    # if [ ! $? -eq 0 ]; then
    #   return 4
    # fi

    overlay_mount_192_168_0_90

    echo "sshpass -p ${l_pass} scp ${src_mediaclip} ${l_user}@${l_ip}:/usr/html/axis-cgi"
    sshpass -p "${l_pass}" scp "${src_mediaclip}" "${l_user}"@"${l_ip}":"/usr/html/axis-cgi"

    echo "sshpass -p ${l_pass} scp ${src_playclip} ${l_user}@${l_ip}:/usr/html/axis-cgi"
    sshpass -p "${l_pass}" scp "${src_playclip}" "${l_user}"@"${l_ip}":"/usr/html/axis-cgi"

    ssh_192_168_0_90_execute "systemctl restart ${l_systemd_name}"

    return 0
  else
    echo "'${project}' is not supported" >&2
    return 3
  fi

  before_sha256="$(sha256sum ${l_source})"

  overlay_mount_192_168_0_90_async

  devtool_build "${project}"
  if [ ! $? -eq 0 ]; then
    return 4
  fi

  if [ ! -e ${l_source} ]; then
    echo "missing '${l_source}'"
    return 5
  fi

  if [ ! -f ${l_source} ]; then
    echo "is not a file '${l_source}'"
    return 5
  fi

  after_sha256="$(sha256sum ${l_source})"

  echo "- curl"

  setup_ssh_eager

  ssh_192_168_0_90_execute "systemctl stop ${l_systemd_name}"
  local res=$?
  if [ $res -eq 0 ]; then
    ssh_192_168_0_90_execute "echo '=${project}====================================' >> /var/log/error.log"

    before_camera_sha256=$(sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "sha256sum ${l_dest}")

    echo "- scp ${l_source} to ${l_dest}"
    sshpass -p "${l_pass}" scp -q "${l_source}" "${l_user}"@"${l_ip}":"${l_dest}"
    local res=$?

    if [ $res -eq 0 ]; then
      after_camera_sha256=$(sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "sha256sum ${l_dest}")

      # echo "- systemctl start ${l_systemd_name}"
      # sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "systemctl start ${l_systemd_name}"
      # local res=$?
      # return $res

      echo "# before  LOCAL: ${before_sha256}"
      echo "# after   LOCAL: ${after_sha256}"
      echo "# before CAMERA: ${before_camera_sha256}"
      echo "# after  CAMERA: ${after_camera_sha256}"

      res=1
      if [ $l_reboot = true ]; then
        reboot_192_168_0_90
        res=$?
      elif [ $l_systemd = true ]; then
        ssh_192_168_0_90_execute "systemctl start ${l_systemd_name}"
        res=$?
      else
        echo "none"
      fi
    fi
  fi

  if [ $res -eq 0 ]; then
    notify-send "deploy '${project}' [DONE]"
    echo "OK"
  else
    notify-send "deploy '${project}' [FAILED]"
    echo "FAILED"
  fi

  return $res
}

function rtags_all(){
  if ! valid_build_dir; then
    return 1
  fi

  local sources="${BUILDDIR}/workspace/sources"

  for f in "${sources}"/*; do
    if [ -d "${f}" ]; then
      local git_root="${f}/.git"

      if [ -e "${git_root}" ]; then

        echo "# $(dirname ${f})"
        $HOME/dotfiles/lib/bitbake_rtags.sh "${f}"
      else

        echo "should be a git repo: '$git_root'" >&2
        return 1
      fi
    fi
  done

  date
}

function devtool_modify() {
  if ! valid_build_dir; then
    return 1
  fi

  local dist_root="${BUILDDIR}/../.."
  local lwd="$(pwd)"

  local failed=""
  local success=""

  # if [ ! -e "${dist_root}/.git" ]; then
  #   echo "Is not a repo">&2
  #   return 1
  # fi


  local proj=( "$@" )
  for cur in "${proj[@]}"; do
    echo "##### devtool modify \"$cur\""
    devtool modify $cur
    if [ $? -eq 0 ]; then
      success="${success} ${cur}"
    else
      failed="${failed} ${cur}"
    fi
    # if [ $? -eq 0 ];then
    #   cd "${dist_root}"
    #   git add .
    #   git commit -m "$cur"
    #   cd "${lwd}"
    # fi
  done

  local msg="modify done"
  if [ ! -z "${success}" ]; then
    success="success: ${success}"
  fi

  if [ ! -z "${failed}" ]; then
    failed="failed: ${failed}"
  fi

  if [ -z "${success}" ]; then
    notify-send "${msg}" "${failed}"
  elif [ -z "${failed}" ]; then
    notify-send "${msg}" "${success}"
  else
    notify-send "${msg}" "${success}" "${failed}"
  fi
}

function ssh_192_168_0_90_execute(){
  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"

  local cmd="$1"

  echo "sshpass -p ${l_pass} ssh -q ${l_user}@${l_ip} \"${cmd}\""
  sshpass -p "${l_pass}" ssh -qt ${l_user}@${l_ip} "${cmd}"
  return $?
}


function reboot_192_168_0_90_async() {
  local cmd="/usr/sbin/reboot;sleep 4"

  # ssh_192_168_0_90_execute "${cmd}"
  # return $?

  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"

    # TODO maybe have ssh "-o ConnectTimeout 1" timeout of 1sec
  echo "sshpass -p ${l_pass} ssh -q -o \"ConnectTimeout 1\" ${l_user}@${l_ip} \"${cmd}\""
  sshpass -p "${l_pass}" ssh -qt -o "ConnectTimeout 1" ${l_user}@${l_ip} "${cmd}"
  return $?
}

function reboot_192_168_0_90() {
  reboot_192_168_0_90_async
  sleep 5

  setup_ssh_eager
  return $?
}

function flash_192_168_0_90_ftp() {
  # TODO grep for "Error: No custom firmware certificate for camera group 'axis-devel-ambarella-s5l'."
  local l_user="root"
  local l_pass="pass"
  local l_ip="192.168.0.90"
  local l_image="./fimage"

function http_ok() {
  local cnt=10
  sleep "${cnt}s"
  setup_ssh_eager > /dev/null
  res=$?

  if [ $res -eq 0 ]; then
    notify-send "OK ssh"
  fi
}

  if [[ -n "${1}" ]]; then
    local l_image="${1}"
  elif [[ -n "${BUILDDIR}" ]]; then
    if ! valid_build_dir; then
      return 1
    fi
    local l_image="${BUILDDIR}/fimage"
  fi

  if [ ! -e "${l_image}" ]; then
    notify-send "ERROR missing '${l_image}'"
    echo "missing '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  if [ ! -f "${l_image}" ]; then
    notify-send "ERROR not a file '${l_image}'"
    echo "not a file '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  sleep 1
  echo
  echo
  sha256sum "${l_image}"
  date
  echo "flashing '${l_image}'"

  axis_enable_root_192_168_0_90
  sleep 2

  # ftp -u ftp://${l_user}:${l_pass}@${l_ip}/flash_all ${l_image}
  # if [ ! $? -eq 0 ]; then
    $HOME/development/axis/tpp/ff enable-ftp
    local ret=$?
    if [ ${ret} -eq 0 ]; then
      local l_fwmgr_local="/tmp/fwmgr.conf"
      local l_fwmgr_remote="/etc/fwmgr.conf"
      local res=0

      sleep 2s

      rm ${l_fwmgr_local} 2> /dev/null

      echo "sshpass -p ${l_pass} scp -q ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
      sshpass -p "${l_pass}" scp -q "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
      if [ -f ${l_fwmgr_local} ]; then
        ssh_192_168_0_90_execute "rm ${l_fwmgr_remote}"

        reboot_192_168_0_90
        sleep 5s
      fi

      ftp -u ftp://${l_user}:${l_pass}@${l_ip}/flash_all ${l_image}
      local ret=$?
      if [ ${ret} -eq 0 ]; then
        notify-send "flashing ${l_ip} [DONE]" "${l_image} [DONE]"
        http_ok &
      else
        notify-send "flashing ${l_ip} [FAILED]" "${l_image} [FAILED]"
      fi
    fi
  # fi

  date
  return ret
}

function netboot_192_168_0_90(){

  local l_image="./fimage"
  local l_machine=""

  if [[ -n "${1}" ]]; then
    local l_image="${1}"
  elif [[ -n "${BUILDDIR}" ]]; then
    if ! valid_build_dir; then
      return 1
    fi
    local l_image="${BUILDDIR}/fimage"
  fi

  if [ ! -e "${l_image}" ]; then
    notify-send "ERROR missing '${l_image}'"
    echo "missing '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  if [ ! -f "${l_image}" ]; then
    notify-send "ERROR not a file '${l_image}'"
    echo "not a file '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  local l_marker="${BUILDDIR}/spmarker"
  if [[ -e "${l_marker}" ]]; then
    local l_machine="$(cat ${l_marker})"
  fi

  echo "image '${l_image}'"
  local l_machine="$(basename ${BUILDDIR})"
  echo "machine '${l_machine}'"

  # axis_enable_root_192_168_0_90
  #
  # $HOME/development/axis/tpp/ff enable-ssh
  # if [ ! $? -eq 0 ]; then
  #   echo "failed to enable-ssh"
  #   return 1
  # fi
  sleep 1s

  $HOME/development/axis/tpp/ff :netboot
  sleep 1s

  if [[ "${l_machine}"="m3066-v" ]]; then
    echo "boot_axis -F -i ${l_image} -W 7AC -v"
    boot_axis -F -i "${l_image}" -W 7AC -v
    local ret=$?
  elif [[ "${l_machine}"="m3075-v" ]]; then
    echo "boot_axis -F -i ${l_image} -W 7AD -v"
    boot_axis -F -i "${l_image}" -W 7AD -v
    local ret=$?
  # elif [[ "${l_machine}"="p3225-lv-mkii" ]]; then
  #   $HOME/development/axis/tpp/ff enable-ssh
  #   sleep 100ms
  #   $HOME/development/axis/tpp/ff :netboot
  #   sleep 1s
  #   echo "boot_axis -F -i \"${l_image}\" -W 705.4 -v"
  #   boot_axis -F -i "${l_image}" -W 705.4 -v
  #   local ret=$?
  elif [[ "${l_machine}"="p3235-lv" ]]; then
    echo "boot_axis -F -i "${l_image}" -W 77A -v"
    boot_axis -F -i "${l_image}" -W 77A -v
    local ret=$?
  else
    boot_axis -F -i "${l_image}" -v
    local ret=$?
  fi

  if [ ${ret} -eq 0 ]; then
    notify-send "netboot ${l_machine} [DONE]" "${l_image} [DONE]"
  else
    notify-send "netboot ${l_machine} [FAILED]" "${l_image} [FAILED]"
  fi

  date
  return ret
}

function bitbake_axis-image-cvp() {
  if ! valid_build_dir; then
    return 1
  fi
  # TODO time
  date

  local fimage="${BUILDDIR}/fimage"
  local fimage_before=$(sha256sum "${fimage}")

  bitbake axis-image-cvp
  local ret=$?
  if [ ${ret} -eq 0 ]; then
    notify-send "Build [SUCCESS]"
  else
    notify-send "Build [FAILED]"
  fi
  date

  local fimage_after=$(sha256sum "${fimage}")

  echo "# ${fimage}"
  echo "before: ${fimage_before}"
  echo "after : ${fimage_after}"
  echo
  echo

  return $ret
}

#ffbuild -c monolith-unittest
#bitbake monolith:do_check
function bitbake_clean_all() {
  #                clean # does cleanup work dirs?
  # devtool build -c gstreamer1.0-plugins-bad
  if ! valid_build_dir; then
    return 1
  fi
  local l_workspace="${BUILDDIR}/workspace/sources"

  if [ ! -e ${l_workspace} ]; then
    echo "${l_workspace} does not exist">&2
    return 2
  fi

  date
  echo "###bitbake -c clean $(cd ${l_workspace}; ls -d -- */ | tr '/' ' ' | xargs)">&2

  bitbake -c clean $(cd ${l_workspace}; ls -d -- */ | tr '/' ' ' | xargs)
  local res=$?

  if [ ${res} -eq 0 ]; then
    notify-send "CLEAN [SUCCESS]"
  else
    notify-send "CLEAN [FAILED]"
  fi
  date

  return $res
}

function bitbake_touch_all() {
  if ! valid_build_dir; then
    return 1
  fi
  local l_workspace="${BUILDDIR}/workspace/sources"

  if [ ! -e ${l_workspace} ]; then
    echo "${l_workspace} does not exist">&2
    return 2
  fi

  cd ${l_workspace}
  ack -f --cpp --fortran --shell --ignore-dir=oe-workdir --ignore-dir=oe-logs -r -- . | xargs touch
  local res=$?
  cd -

  return ${res}
}

function bitbake_clean() {
  if ! valid_build_dir; then
    return 1
  fi

  local proj=( "$@" )
  for cur in "${proj[@]}"; do
    echo "###bitbake -c clean ${cur}">&2
    bitbake -c clean "${cur}"
  done
}

function entr_devtool_build(){
  if ! valid_build_dir; then
    return 1
  fi

  local project="${1}"
  local l_workspace="${BUILDDIR}/workspace/sources/${project}"

  if [ ! -e "${l_workspace}" ]; then
    echo "missing workspace '${l_workspace}'">&2
    return 1
  fi

  echo "ack -f --cpp --ignore-dir=oe-workdir --ignore-dir=oe-logs -r ${l_workspace}"
  cd ${l_workspace}
  ack -f --cpp --fortran --shell --ignore-dir=oe-workdir --ignore-dir=oe-logs -r | entr -c "$HOME/dotfiles/lib/devtool_build.sh" "${project}"
  cd -
}

function devtool_build(){
  if ! valid_build_dir; then
    return 1
  fi

  local project="${1}"
  local l_workspace="${BUILDDIR}/workspace/sources/${project}"

  if [ ! -e "${l_workspace}" ]; then
    echo "missing workspace '${l_workspace}'">&2
    return 1
  fi


  time $HOME/dotfiles/lib/devtool_build.sh "${project}"
  local out=$?

  echo ""

  return out
}


function env_setup() {
  local l_args="${@}"

  # -w DIR, --workdir DIR the work directory to setup

  getopt --test
  if [[ $? -ne 4 ]]; then
    echo "I’m sorry, `getopt --test` failed in this environment."
    return 1
  fi

  local l_options="w:m:g:j:"
  local l_longopts="workdir:,manifest-branch:,groups:,jobs:"

  # -use ! and PIPESTATUS to get exit code with errexit set
  # -temporarily store output to be able to check for errors
  # -activate quoting/enhanced mode (e.g. by writing out “--options”)
  # -pass arguments only via   -- "$@"   to separate them correctly
  ! PARSED=$(getopt --options=$l_options --longoptions=$l_longopts --name "$0" -- "$@")
  if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    return 2
  fi
  # read getopt’s output this way to handle the quoting right:
  eval set -- "$PARSED"

  local l_workdir=

  while true; do
    case "$1" in
      -w|--workdir)
        # echo "workdir $2"
        l_workdir="${2}"
        shift 2
        ;;
      -m|--manifest-branch)
        shift 2
        ;;
      -g|--groups)
        shift 2
        ;;
      -j|--jobs)
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
      echo "spooky Unknown argument"
      return 3
      ;;
    esac
  done

  if [[ -z "${l_workdir}" ]]; then
    echo "workspace is not set"
    return 4
  fi

  if [[ -e "${l_workdir}" ]]; then
    echo "workspace already exist '${l_workdir}'"
    return 5
  fi

  "${l_args}"
  if [[ ! $? -eq 0 ]]; then
    return $?
  fi

  if [[ ! -e "${l_workdir}" ]]; then
    echo "workspace does not exist '${l_workdir}'"
    return 6
  fi

  if [[ "$(readlink -f ${l_workdir})" != "$(pwd)" ]]; then
    echo "'$(readlink -f ${l_workdir})' missmatch '$(pwd)'"
    return 7
  fi

  git init
  cp ~/Dropbox/axis/gitignore .gitignore
  git add .
  git commit -m "initial"
}

# TODO portcast-conf
function portcast_features(){
  function dumpProperties(){
    function setProperty(){
      local key=$1
      local value=$2
      local file=$3

      awk -v pat="^$key=" -v value="$key=$value" '{ if ($0 ~ pat) print value; else print $0; }' $file > $file.tmp
      mv $file.tmp $file
    }

    function getProperty() {
      local key=$1
      local file=$2
      local value=$(cat "$file" | grep "$key" | cut -d'=' -f2)
      echo $value
    }

    function listProperties(){
      local file=$1

      cat "${file}" | cut -d'=' -f1 | xargs
    }

    if [ $# -eq 0 ]; then
      return 10
    fi

    local tmp_file="$(mktemp /tmp/tmp.XXXXXXXXXXXXXX)"

    # echo "arg: $1"
    cat $1 > $tmp_file
    shift

    while [ $# -gt 0 ]; do
      local args=($(listProperties "$1"))

      for key in ${args[@]}; do
        local value=$(getProperty "${key}" "$1")
        # echo "${value} = getProperty ${key} $1"
        setProperty "${key}" "${value}" "${tmp_file}"
      done

      shift
    done

    while IFS='' read -r line || [[ -n "$line" ]]; do
      echo "- ${line}"
    done < "${tmp_file}"

  # echo "${default_audiocontrol_conf}"
  # if [ -e "${audiocontrol_conf_product}" ]; then
  # awk -F= '!a[$1]++' "${default_audiocontrol_prod}" "${audiocontrol_conf_product}"
  # fi

    rm ${tmp_file}

    # hides functions from global scope
    unset -f setProperty getProperty listProperties
  }

  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local machine_root=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")

  local audiocontrol_conf_root="${BUILDDIR}/workspace/sources/audiocontrol-conf"
  local default_audiocontrol_conf="${audiocontrol_conf_root}/products/default_audiocontrol_prod.inc"

  # echo grep "AXIS_CONFIG_PORTCAST=y" "${machine_root}" -lir
  # echo "${build_root}"
  # echo "${machine_root}"

  local machine_configs=( $(grep "AXIS_CONFIG_PORTCAST=y" "${machine_root}" -lir) )

  # echo ${machine_configs}

  for ax in ${machine_configs[@]};
  do
    local ax_name="$(basename ${ax})"
    local product_name="$(cut -d '.' -f1 <<< $ax_name)"
    local audiocontrol_conf_product="${audiocontrol_conf_root}/products/${product_name}/audiocontrol_prod.inc"

    echo "========================================"
    echo "# ${product_name}"
    grep AXIS_CONFIG_AUDIO_OUTPUTS "${ax}" | xargs echo "-"
    grep AXIS_CONFIG_AUDIO_SOURCES "${ax}" | xargs echo "-"
    grep "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_DEFAULT" "${ax}" | xargs echo "- default:"
    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_[0-9]+" "${ax}" | xargs -n1 echo "-"

    echo "## I/O"
    grep AXIS_CONFIG_GPIOMAP "${ax}"| xargs echo "?"
    grep AXIS_CONFIG_IO_INPUTS "${ax}" | xargs echo "?"

    echo "## audiocontrol-conf"
    if [ -e "${audiocontrol_conf_product}" ]; then
      dumpProperties "${default_audiocontrol_conf}" "${audiocontrol_conf_product}"
    else
      dumpProperties "${default_audiocontrol_conf}"
    fi

    echo
  done
}

function dump_sample_rates(){
  local name="$(basename ${1})"
  name=${name/".axis-config"/""}
  echo "# ${name}"
  grep -E "AXIS_CONFIG_AUDIO" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${1}" | xargs echo "-"
  grep -E "AXIS_CONFIG_PORTCAST" "${1}" | xargs echo "-"
  echo ""
}

function sample_rate_holes(){
  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
  if [ ! -d ${dir} ]; then
    echo "'$dir' not a dir"
    return 1
  fi

  for cur in "${dir}"/*; do
    local res=0
    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      res=8
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 8 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=16
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 16 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=32
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 32 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=44
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 44 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=48
    fi
  done
}

function only_one_sample_rate(){
  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
  if [ ! -d ${dir} ]; then
    echo "'$dir' not a dir"
    return 1
  fi

  for cur in "${dir}"/*; do
    local cnt=0
    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    if [ $cnt -eq 1 ]; then
      echo "${cnt}"
      dump_sample_rates "${cur}"
    fi
  done
}

# setxkbmap -option caps:escape

# release shares (daily build?)

# /n/axis_releases/oe/m3048-p/CVP/18.45.5_1
# share:
# /n/slask/fredriol
# \\storage03\n_slask\fredriol

# vim: set ft=sh:
